# 📚 Storybook 9 Best Practices - Полный Учебник

**На примере компонента TaskInput**

---

## 📖 Содержание

1. [🐛 Критический баг: Toaster не работает!](#1-критический-баг-toaster-не-работает)
2. [📐 Структура Stories файла](#2-структура-stories-файла)
3. [🎛️ Meta Configuration](#3-meta-configuration)
4. [🎮 Playground Pattern](#4-playground-pattern)
5. [📝 Stories - 8 примеров](#5-stories---8-примеров)
6. [🎬 Play Functions](#6-play-functions)
7. [🎭 Mocking в Storybook 9](#7-mocking-в-storybook-9)
8. [🎨 Args Композиция](#8-args-композиция)
9. [🎚️ ArgTypes Best Practices](#9-argtypes-best-practices)
10. [🎭 Decorators](#10-decorators)
11. [✅ Best Practices Checklist](#11-best-practices-checklist)
12. [📦 Полный TaskInput.stories.tsx](#12-полный-taskinputstoriestsx)
13. [📚 STORYBOOK.md Update](#13-storybookmd-update)

---

## 1. 🐛 Критический баг: Toaster не работает!

### Проблема

В текущем проекте есть **критический баг**: компонент `<Toaster />` определен в `src/components/ui/sonner.tsx`, но **НИКОГДА не импортируется и не используется** ни в одном файле!

Результат: все вызовы `toast()` в хуках `useTodoCreate` и `useTodoDelete` не показывают никаких уведомлений пользователю.

```typescript
// src/hooks/useTodoCreate.ts
toast.success('Task created'); // ❌ Не работает! Toaster не отрендерен
```

### Решение: 2 места, где нужен Toaster

#### ✅ Решение #1: Добавить в layout.tsx (для основного приложения)

**Файл:** `src/app/layout.tsx`

```typescript
import { ThemeProvider } from '@/components/theme-provider';
import { Toaster } from '@/components/ui/sonner'; // 👈 ДОБАВИТЬ этот импорт
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import './globals.css';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" suppressHydrationWarning>
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          {children}
          <Toaster /> {/* 👈 ДОБАВИТЬ здесь, после {children} */}
        </ThemeProvider>
      </body>
    </html>
  );
}
```

**📚 Объяснение:**

- **Где добавлять:** ВНУТРИ `<ThemeProvider>`, после `{children}`
- **Почему внутри ThemeProvider:** Toaster использует `useTheme()` hook, который требует Theme context
- **Почему после children:** Toasts должны отображаться ПОВЕРХ контента (z-index)
- **Почему глобально:** Toaster нужен на всех страницах, рендерится один раз

#### ✅ Решение #2: Добавить в preview.ts (для Storybook)

**Файл:** `.storybook/preview.ts`

```typescript
import { withThemeByDataAttribute } from '@storybook/addon-themes';
import type { Decorator, Preview } from '@storybook/nextjs-vite';
import { Toaster } from 'sonner'; // 👈 ДОБАВИТЬ импорт
import '../src/app/globals.css';

/* snipped for brevity */

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📚 ЧТО ДЕЛАЕТ:
// Decorator, который добавляет Toaster ко всем stories
//
// 🤔 ПОЧЕМУ ТАК:
// - Storybook рендерит stories ИЗОЛИРОВАННО
// - layout.tsx НЕ применяется к stories
// - Без этого decorator, toast() вызовы не будут работать в Storybook
//
// 💡 КОГДА ИСПОЛЬЗОВАТЬ:
// Для глобальных UI компонентов, которые нужны всем stories
// (модалы, тосты, tooltips providers, etc)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const withToaster: Decorator = (Story) => (
  <>
    <Story />
    <Toaster />
  </>
);

export const decorators = [
  withThemeByDataAttribute({
    themes: {
      light: 'light',
      dark: 'dark',
    },
    defaultTheme: 'light',
    attributeName: 'data-mode',
  }),
  withToaster, // 👈 ДОБАВИТЬ здесь, ПОСЛЕ theme decorator
];

const preview: Preview = {
  parameters: {
    controls: {
      matchers: {
        color: /(background|color)$/i,
        date: /Date$/i,
      },
    },
    a11y: {
      test: 'todo',
    },
    backgrounds: { disabled: true },
    nextjs: {
      appDirectory: true,
    },
  },
};

export default preview;
```

**📚 Объяснение:**

- **Почему decorator:** Storybook не использует `layout.tsx` из Next.js
- **Порядок важен:** Theme decorator ПЕРЕД Toaster, чтобы theme context был доступен
- **Fragment wrapper:** `<>...</>` позволяет вернуть несколько элементов

**⚠️ ВАЖНО:**
После этих изменений перезапусти Storybook: `npm run storybook`

---

## 2. 📐 Структура Stories файла

### Анатомия .stories.tsx файла

Каждый stories файл следует стандартной структуре:

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ IMPORTS
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
import type { Meta, StoryObj } from '@storybook/nextjs-vite';
// 👆 Типы для TypeScript: Meta (конфигурация) и StoryObj (типизация stories)

import { ComponentName } from './index';
// 👆 Импорт компонента, который документируем

import { fn, expect, userEvent, within } from 'storybook/test';
// 👆 (Опционально) Утилиты для Play functions и интерактивных тестов

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ META OBJECT
// Конфигурация компонента для Storybook
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const meta = {
  title: 'Category/ComponentName',
  component: ComponentName,
  parameters: {
    /* ... */
  },
  args: {
    /* default values */
  },
  argTypes: {
    /* controls config */
  },
  decorators: [
    /* wrappers */
  ],
  tags: ['autodocs'],
} satisfies Meta<typeof ComponentName>;

export default meta;
// 👆 Default export обязателен! Storybook ищет meta здесь

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3️⃣ TYPE EXPORT
// Типизация для всех stories
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
type Story = StoryObj<typeof meta>;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 4️⃣ STORIES (Named Exports)
// Каждая story = отдельный пример компонента
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Playground: Story = {
  // args, render, play, etc
};

export const Default: Story = {
  args: {
    /* specific props */
  },
};

export const AnotherExample: Story = {
  args: {
    /* ... */
  },
};
```

**📚 Ключевые моменты:**

1. **Default Export** - обязательно для `meta`
2. **Named Exports** - каждая story (PascalCase naming)
3. **Type Story** - наследует типы из meta
4. **satisfies Meta<typeof Component>** - строгая типизация

---

## 3. 🎛️ Meta Configuration

Meta object - это сердце stories файла. Здесь определяются настройки для ВСЕХ stories компонента.

### 3.1 `title` - Иерархия в Sidebar

```typescript
const meta = {
  title: 'Design System/TaskInput',
  //      └─ Folder    └─ Component name
};
```

**📚 ЧТО ДЕЛАЕТ:**

- Определяет путь в sidebar Storybook UI
- Слэш `/` создает вложенность (папки)

**🤔 ПОЧЕМУ ТАК:**

- Организация компонентов по категориям
- "Design System" - для UI primitives
- "Features" - для feature components
- "Pages" - для полных страниц

**💡 ПРИМЕРЫ:**

```typescript
'Design System/Button'      → Design System > Button
'Design System/Form/Input'  → Design System > Form > Input
'Features/TodoList'         → Features > TodoList
```

---

### 3.2 `component` - Ссылка на компонент

```typescript
const meta = {
  component: TaskInput,
};
```

**📚 ЧТО ДЕЛАЕТ:**

- Связывает stories с компонентом
- Автоматически извлекает props для Controls
- Генерирует autodocs

**🤔 ПОЧЕМУ ОБЯЗАТЕЛЬНО:**

- Без этого Storybook не знает какой компонент рендерить
- Controls не будут работать
- Autodocs не сгенерируется

---

### 3.3 `parameters` - Настройки отображения

```typescript
const meta = {
  parameters: {
    layout: 'centered', // 'centered' | 'fullscreen' | 'padded'
    backgrounds: {
      default: 'light',
      values: [
        { name: 'light', value: '#ffffff' },
        { name: 'dark', value: '#000000' },
      ],
    },
    docs: {
      description: {
        component: 'TaskInput - multiline textarea with auto-resize',
      },
    },
  },
};
```

**📚 ОПЦИИ:**

| Parameter              | Значения           | Когда использовать                 |
| ---------------------- | ------------------ | ---------------------------------- |
| `layout: 'centered'`   | Центрирование      | Form components, buttons, small UI |
| `layout: 'fullscreen'` | На весь экран      | Pages, layouts                     |
| `layout: 'padded'`     | С padding          | Default, большинство компонентов   |
| `backgrounds`          | Custom backgrounds | Для тестирования контраста         |

**💡 ДЛЯ TASKINPUT:**

```typescript
parameters: {
  layout: 'centered', // Форма лучше смотрится по центру
}
```

---

### 3.4 `tags` - Автодокументация

```typescript
const meta = {
  tags: ['autodocs'],
};
```

**📚 ЧТО ДЕЛАЕТ:**

- `'autodocs'` - генерирует Docs page автоматически
- Docs включает: props table, description, examples

**🤔 КОГДА ИСПОЛЬЗОВАТЬ:**

- ✅ Для public компонентов (UI библиотека)
- ❌ Для internal/experimental компонентов

---

### 3.5 `args` - Default значения для ВСЕХ stories

```typescript
const meta = {
  args: {
    label: 'Task Description',
    placeholder: 'Enter your task...',
    required: true,
    disabled: false,
  },
};
```

**📚 ЧТО ДЕЛАЕТ:**

- Эти значения применяются ко ВСЕМ stories по умолчанию
- Stories могут переопределить через свои `args`

**🤔 ПОЧЕМУ В META, А НЕ В КАЖДОЙ STORY:**

- ❌ **Плохо:** Дублирование в каждой story

```typescript
export const Story1: Story = {
  args: { label: 'Label', placeholder: 'Placeholder', required: true },
};
export const Story2: Story = {
  args: { label: 'Label', placeholder: 'Placeholder', disabled: true },
};
// 👆 Дублирование! label и placeholder повторяются
```

- ✅ **Хорошо:** Default в meta, override в stories

```typescript
const meta = {
  args: { label: 'Label', placeholder: 'Placeholder' }, // default
};
export const Story1: Story = {
  args: { required: true }, // только разница
};
export const Story2: Story = {
  args: { disabled: true }, // только разница
};
```

**💡 ПРАВИЛО:**

- В `meta.args` - общие для всех props
- В `story.args` - уникальные для конкретного примера

---

### 3.6 `argTypes` - Controls и документация

ArgTypes определяют как props отображаются в Controls panel и Docs.

```typescript
const meta = {
  argTypes: {
    label: {
      control: 'text',
      description: 'Label text displayed above the input',
      table: {
        category: 'Content',
        type: { summary: 'string' },
        defaultValue: { summary: 'Task Description' },
      },
    },
    required: {
      control: 'boolean',
      description: 'Whether the input is required',
      table: {
        category: 'Validation',
        type: { summary: 'boolean' },
        defaultValue: { summary: 'true' },
      },
    },
    disabled: {
      control: 'boolean',
      description: 'Whether the input is disabled',
      table: {
        category: 'State',
        type: { summary: 'boolean' },
      },
    },
  },
};
```

**📚 СТРУКТУРА ArgType:**

```typescript
propName: {
  control: 'text',           // Тип контрола в UI
  description: '...',        // Описание для Docs
  table: {
    category: 'Content',     // Группировка в tabs
    type: { summary: 'string' },
    defaultValue: { summary: 'Default' },
  },
}
```

**🎚️ ТИПЫ CONTROLS:**

| Control Type | Для чего           | Пример                          |
| ------------ | ------------------ | ------------------------------- |
| `'text'`     | Строки             | label, placeholder              |
| `'boolean'`  | Boolean            | disabled, required              |
| `'number'`   | Числа              | minRows, maxRows                |
| `'select'`   | Enum/Union         | variant: 'default' \| 'outline' |
| `'radio'`    | Малое кол-во опций | size: 'sm' \| 'md' \| 'lg'      |
| `'color'`    | Цвета              | backgroundColor                 |
| `'date'`     | Даты               | createdAt                       |
| `'object'`   | Объекты            | style: {}                       |
| `'array'`    | Массивы            | items: []                       |

**💡 КАТЕГОРИИ:**

Группируют props в Docs table:

```typescript
argTypes: {
  // Контент
  label: { table: { category: 'Content' } },
  placeholder: { table: { category: 'Content' } },

  // Валидация
  required: { table: { category: 'Validation' } },
  minLength: { table: { category: 'Validation' } },

  // Состояние
  disabled: { table: { category: 'State' } },
  loading: { table: { category: 'State' } },

  // Layout
  minRows: { table: { category: 'Layout' } },
  maxRows: { table: { category: 'Layout' } },
}
```

**🤔 ПОЧЕМУ КАТЕГОРИИ:**

- Docs table становится читаемой
- Props сгруппированы логически
- Легко найти нужный prop

**⚠️ КОГДА НЕ НУЖЕН ArgType:**
Storybook автоматически определяет control из TypeScript типов:

```typescript
// Component props
interface ButtonProps {
  variant: 'default' | 'outline'; // auto -> select
  disabled: boolean; // auto -> boolean
  label: string; // auto -> text
}

// argTypes НЕ ОБЯЗАТЕЛЬНЫ, но можно добавить для:
// - description
// - categories
// - custom control options
```

---

### 3.7 `decorators` - Wrappers для компонента

Decorators оборачивают story для улучшения визуализации или добавления context.

```typescript
const meta = {
  decorators: [
    (Story) => (
      <div style={{ padding: '2rem', maxWidth: '600px' }}>
        <Story />
      </div>
    ),
  ],
}
```

**📚 ЧТО ДЕЛАЕТ:**

- Оборачивает КАЖДУЮ story этого компонента
- Можно добавить padding, background, providers, etc

**🤔 ПОЧЕМУ:**

- **Padding:** Компонент не прилипает к краям canvas
- **MaxWidth:** Форма не растягивается на весь экран
- **Focus ring видно:** Без padding focus outline обрезается

**💡 ПРИМЕРЫ:**

```typescript
// Padding wrapper
decorators: [
  (Story) => (
    <div style={{ padding: '3rem' }}>
      <Story />
    </div>
  ),
]

// Provider wrapper (например, для Context)
decorators: [
  (Story) => (
    <FormProvider>
      <Story />
    </FormProvider>
  ),
]

// Multiple decorators (применяются справа налево)
decorators: [
  (Story) => <Provider><Story /></Provider>,  // 2nd
  (Story) => <div className="p-4"><Story /></div>, // 1st
]
```

**🎯 GLOBAL vs STORY-LEVEL:**

```typescript
// Global (в .storybook/preview.ts) - для ВСЕХ stories
export const decorators = [
  (Story) => <><Story /><Toaster /></>,
];

// Component-level (в meta) - для stories этого компонента
const meta = {
  decorators: [
    (Story) => <div className="p-4"><Story /></div>,
  ],
};

// Story-level - для ОДНОЙ story
export const SpecialCase: Story = {
  decorators: [
    (Story) => <div className="bg-red-50"><Story /></div>,
  ],
};
```

---

## 4. 🎮 Playground Pattern

### Что такое Playground Story?

**Playground** - это интерактивная "песочница" для тестирования компонента со ВСЕМИ доступными props через Storybook UI.

```typescript
export const Playground: Story = {
  // Все args из meta автоматически доступны в Controls panel
  // Пользователь может менять любой prop в реальном времени
};
```

**📚 ЗАЧЕМ НУЖЕН:**

- **Интерактивное тестирование:** Изменяй props в UI, смотри результат сразу
- **Документация:** Показывает ВСЕ доступные props
- **Debugging:** Быстро найти проблемную комбинацию props
- **Демо:** Показать stakeholders все возможности компонента

**🤔 ПОЧЕМУ ПЕРВАЯ STORY:**

- Storybook открывает первую story по умолчанию
- Playground = main example с полным контролем
- Остальные stories = конкретные use cases

---

### Playground для TaskInput

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎮 PLAYGROUND - Интерактивная песочница
//
// 📚 ЧТО ДЕЛАЕТ:
// - Все props доступны через Controls panel справа
// - Можно менять label, placeholder, disabled, etc в реальном времени
// - Результат обновляется мгновенно
//
// 🤔 ПОЧЕМУ ТАК:
// - Не нужен `render` - компонент рендерится с args автоматически
// - Все args из meta применяются по умолчанию
// - Можно добавить специфичные args если нужно
//
// 💡 КОГДА ИСПОЛЬЗОВАТЬ:
// - Всегда делай Playground первой story
// - Для компонентов с >3 props
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Playground: Story = {
  // Пустой объект! Все args наследуются из meta
  // Controls panel автоматически покажет все argTypes
};
```

---

### Сравнение: Playground vs Default Story

```typescript
// ❌ ПЛОХО - Default как Playground (дублирование)
export const Default: Story = {
  args: {
    label: 'Task Description',
    placeholder: 'Enter your task...',
    required: true,
    disabled: false,
    submitLabel: 'Create task',
    minRows: 1,
    maxRows: 5,
  },
};
// 👆 Все эти args уже в meta! Дублирование

// ✅ ХОРОШО - Playground пустой (наследует из meta)
export const Playground: Story = {};

// ✅ ХОРОШО - Default показывает МИНИМУМ для работы
export const Default: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
  },
};
```

---

### Когда использовать `render` в Playground

**Render функция НЕ НУЖНА**, если компонент принимает props напрямую:

```typescript
// ❌ НЕ НУЖНО
export const Playground: Story = {
  render: (args) => <TaskInput {...args} />,
};
// 👆 Storybook сделает это автоматически!

// ✅ ПРАВИЛЬНО
export const Playground: Story = {};
```

**Render функция НУЖНА**, если:

1. **Wrapper нужен для конкретной story:**

```typescript
export const WithForm: Story = {
  render: (args) => (
    <form onSubmit={(e) => { e.preventDefault(); alert('Submitted!') }}>
      <TaskInput {...args} />
      <button type="submit">Submit</button>
    </form>
  ),
};
```

2. **State нужен:**

```typescript
export const Controlled: Story = {
  render: (args) => {
    const [value, setValue] = React.useState('');
    return <TaskInput {...args} value={value} onChange={setValue} />;
  },
};
```

3. **Multiple компонентов:**

```typescript
export const AllVariants: Story = {
  render: () => (
    <div className="space-y-4">
      <TaskInput label="Small" minRows={1} maxRows={3} />
      <TaskInput label="Medium" minRows={2} maxRows={5} />
      <TaskInput label="Large" minRows={3} maxRows={10} />
    </div>
  ),
};
```

---

### Пример: Button Playground (reference)

Для сравнения, посмотрим на Playground из `Button.stories.tsx`:

```typescript
// src/components/ui/Button/Button.stories.tsx
export const Playground = {
  args: {
    children: 'Button',
    icon: 'bell', // Custom arg (не в Button props)
  },
  render: ButtonIcon, // Custom render для обработки icon
} satisfies Story;

// ButtonIcon - helper для рендера иконки
const ButtonIcon = ({ icon, children, size, ...args }: ButtonStoryProps) => (
  <Button {...args} size={size}>
    {icon !== 'none' && iconMap[icon as iconType]}
    {(size !== 'icon' || !icon) && children}
  </Button>
);
```

**📚 Почему render здесь:**

- `icon` - кастомный arg (НЕ Button prop)
- `ButtonIcon` преобразует `icon` string в React element
- Без `render` - icon не отобразится

**💡 TaskInput НЕ нужен render:**

- Все args = native props компонента
- Никаких трансформаций не требуется

---

## 5. 📝 Stories - 8 примеров

Теперь разберем все 8 stories для TaskInput с полными объяснениями.

### 5.1 Playground (главная интерактивная story)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎮 PLAYGROUND
// Интерактивная песочница с полным контролем
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Playground: Story = {
  // Пустой! Все из meta
};
```

**Use case:** Тестирование всех комбинаций props в UI

---

### 5.2 Default (минималистичный пример)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📄 DEFAULT
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Минимальный рабочий пример с базовыми props
//
// 🤔 ЗАЧЕМ:
// - Quick start для разработчиков
// - "Скопируй этот код и все заработает"
// - Без лишних props
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Default: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
  },
  // Остальные args (required, disabled, etc) наследуются из meta
};
```

---

### 5.3 WithoutLabel (минимум props)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🔍 WITHOUT LABEL
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Компонент БЕЗ label - только placeholder
//
// 🤔 ЗАЧЕМ:
// - Не все формы требуют labels
// - Inline editing, search bars, etc
// - Accessibility через placeholder (не лучшая практика, но бывает)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const WithoutLabel: Story = {
  args: {
    label: undefined, // Override meta
    placeholder: 'Type here...',
  },
};
```

---

### 5.4 WithError (validation state)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ❌ WITH ERROR
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Состояние ошибки валидации (Zod issues)
//
// 🤔 ЗАЧЕМ:
// - Показать как выглядит error state
// - Тестирование стилей ошибки
// - Проверка accessibility (aria-invalid, aria-describedby)
//
// 💡 КАК РАБОТАЕТ:
// issues - массив Zod validation errors
// Компонент рендерит их под input красным текстом
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const WithError: Story = {
  args: {
    issues: [
      {
        code: 'too_small',
        minimum: 3,
        type: 'string',
        inclusive: true,
        exact: false,
        message: 'Task must be at least 3 characters',
        path: ['description'],
      },
    ],
  },
};
```

---

### 5.5 Disabled (disabled state)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🚫 DISABLED
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Disabled state - нельзя редактировать и submit
//
// 🤔 ЗАЧЕМ:
// - Показать визуальное состояние disabled
// - UX: форма заблокирована (loading, недостаточно прав, etc)
// - Проверка accessibility (disabled cursor, opacity, aria-disabled)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Disabled: Story = {
  args: {
    disabled: true,
    defaultValue: 'This field is disabled',
  },
};
```

---

### 5.6 Filled (pre-filled value)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✍️ FILLED
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Форма с предзаполненным значением (edit mode)
//
// 🤔 ЗАЧЕМ:
// - Edit existing todo
// - Pre-filled form на основе URL params / draft
// - Показать как выглядит filled state (не пустой)
//
// 💡 defaultValue vs value:
// - defaultValue: initial value, uncontrolled
// - value: controlled (нужен onChange)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Filled: Story = {
  args: {
    defaultValue: 'Buy groceries for dinner tonight',
  },
};
```

---

### 5.7 LongText (multiline behavior)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📝 LONG TEXT
//
// 📚 ЧТО ПОКАЗЫВАЕТ:
// Поведение textarea с длинным текстом (auto-resize)
//
// 🤔 ЗАЧЕМ:
// - Проверить minRows/maxRows работу
// - Убедиться что scroll появляется корректно
// - Показать UX с длинным контентом
//
// 💡 КАК РАБОТАЕТ:
// - minRows=3: начинается с 3 строк
// - maxRows=6: после 6 строк появляется scroll
// - textarea растет автоматически между min и max
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const LongText: Story = {
  args: {
    label: 'Project Description',
    minRows: 3,
    maxRows: 6,
    defaultValue: `This is a long task description that spans multiple lines.
It demonstrates the auto-resize behavior of the textarea component.
The component will grow from minRows (3) to maxRows (6).
After maxRows, a scrollbar will appear.
This helps maintain good UX with long content.
Users can type as much as they want.`,
  },
};
```

---

### 5.8 Interactive (с Play Function)

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎬 INTERACTIVE
//
// 📚 ЧТО ДЕЛАЕТ:
// Автоматически симулирует user interactions через Play Function
//
// 🤔 ЗАЧЕМ:
// - Демонстрация user flow (type → submit)
// - Автоматическое тестирование
// - Visual regression testing
// - Показать stakeholders как работает компонент
//
// 💡 КАК РАБОТАЕТ:
// 1. play function запускается после render
// 2. userEvent симулирует реальные user actions
// 3. step организует actions в читаемые блоки
// 4. Можно добавить expect для assertions
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Interactive: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('User types task description', async () => {
      const textarea = canvas.getByRole('textbox');
      await userEvent.type(textarea, 'Buy groceries for dinner', { delay: 50 });
    });

    await step('User submits the form', async () => {
      const submitBtn = canvas.getByRole('button', { name: /create task/i });
      await userEvent.click(submitBtn);
    });
  },
};
```

---

## 6. 🎬 Play Functions

Play Functions - это мощный инструмент для автоматизации user interactions прямо в Storybook.

### Что такое Play Function?

**Play Function** - функция, которая автоматически выполняет actions после рендера story.

```typescript
export const MyStory: Story = {
  play: async ({ canvasElement, step, userEvent }) => {
    // Автоматически выполняется после рендера
    const canvas = within(canvasElement);
    await userEvent.type(canvas.getByRole('textbox'), 'Hello');
  },
};
```

**📚 ЗАЧЕМ НУЖНЫ:**

1. **Демонстрация user flows**
   - Показать как пользователь взаимодействует с компонентом
   - Автоматически проигрывается при открытии story

2. **Автоматическое тестирование**
   - Smoke tests прямо в Storybook
   - Можно добавить `expect` assertions
   - Интеграция с @storybook/addon-vitest

3. **Visual regression testing**
   - Chromatic автоматически тестирует stories с play functions
   - Ловит визуальные баги в interactions

4. **Documentation**
   - Живая демонстрация вместо статичных screenshots
   - Stakeholders видят реальное поведение

---

### API Play Function

```typescript
play: async ({ canvasElement, step, args, userEvent }) => {
  // ...
};
```

**Параметры:**

| Параметр        | Тип                   | Описание                   |
| --------------- | --------------------- | -------------------------- |
| `canvasElement` | HTMLElement           | Root element story         |
| `canvas`        | within(canvasElement) | Testing Library queries    |
| `step`          | Function              | Организует actions в блоки |
| `args`          | Object                | Props переданные в story   |
| `userEvent`     | Object                | Симулирует user events     |

---

### `canvas` - DOM Queries

```typescript
const canvas = within(canvasElement);

// Testing Library queries
canvas.getByRole('button');
canvas.getByText('Submit');
canvas.getByLabelText('Email');
canvas.getByPlaceholderText('Enter text...');
canvas.getByTestId('custom-input');

// Async queries (ждут появления)
await canvas.findByRole('button');
await canvas.findByText('Loading...');

// Query variants
canvas.queryByRole('button'); // null если не найден
canvas.getAllByRole('listitem'); // массив всех элементов
```

**💡 BEST PRACTICE:**

- Используй `getByRole` (accessibility-first)
- `getByText` для контента
- `getByTestId` - последний вариант

---

### `userEvent` - User Interactions

```typescript
// Typing
await userEvent.type(canvas.getByRole('textbox'), 'Hello');
await userEvent.type(input, 'Slow typing', { delay: 100 });

// Clicking
await userEvent.click(canvas.getByRole('button'));
await userEvent.dblClick(element);
await userEvent.tripleClick(element);

// Keyboard
await userEvent.keyboard('{Enter}');
await userEvent.keyboard('{Control>}a{/Control}'); // Ctrl+A
await userEvent.tab(); // Tab key

// Clear input
await userEvent.clear(canvas.getByRole('textbox'));

// Select option
await userEvent.selectOptions(canvas.getByRole('listbox'), 'option1');

// Upload file
await userEvent.upload(canvas.getByLabelText('Upload'), file);

// Hover
await userEvent.hover(element);
await userEvent.unhover(element);
```

**⚠️ userEvent vs fireEvent:**

- ✅ `userEvent` - симулирует РЕАЛЬНЫЕ user actions (медленнее, точнее)
- ❌ `fireEvent` - прямой вызов event (быстрее, менее реалистично)

**Всегда используй `userEvent`!**

---

### `step` - Организация Actions

`step` группирует actions в читаемые блоки в Storybook UI.

```typescript
export const MyStory: Story = {
  play: async ({ canvas, step, userEvent }) => {
    await step('Fill in the form', async () => {
      await userEvent.type(canvas.getByLabelText('Email'), 'user@example.com');
      await userEvent.type(canvas.getByLabelText('Password'), 'password123');
    });

    await step('Submit the form', async () => {
      await userEvent.click(canvas.getByRole('button', { name: /submit/i }));
    });

    await step('Verify success message', async () => {
      await expect(canvas.getByText('Success!')).toBeInTheDocument();
    });
  },
};
```

**📚 ПОЧЕМУ STEP:**

- Организует actions логически
- В Storybook UI показывает progress bars
- Легче debug (видно где сломалось)
- Читаемость кода

---

### Примеры Play Functions

#### Пример 1: Простой (type текст)

```typescript
export const SimpleTyping: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    const textarea = canvas.getByRole('textbox');
    await userEvent.type(textarea, 'Hello Storybook!');
  },
};
```

**Use case:** Показать что textarea работает

---

#### Пример 2: С Steps (type + submit)

```typescript
export const TypeAndSubmit: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('User types task', async () => {
      const textarea = canvas.getByRole('textbox');
      await userEvent.type(textarea, 'Buy milk', { delay: 50 });
    });

    await step('User submits', async () => {
      const submitBtn = canvas.getByRole('button', { name: /create/i });
      await userEvent.click(submitBtn);
    });
  },
};
```

**Use case:** Демонстрация полного flow

---

#### Пример 3: С Assertions (проверка ошибок)

```typescript
export const ShowsErrorOnEmptySubmit: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('Submit empty form', async () => {
      const submitBtn = canvas.getByRole('button', { name: /create/i });
      await userEvent.click(submitBtn);
    });

    await step('Verify error message', async () => {
      // Assertions с @testing-library/jest-dom
      const errorMessage = await canvas.findByText(/required/i);
      await expect(errorMessage).toBeInTheDocument();
      await expect(errorMessage).toHaveClass('text-red-500');
    });
  },
};
```

**Use case:** Тестирование валидации

---

### Debugging Play Functions

**Проблема:** Play function падает с ошибкой

**Решения:**

1. **Добавь `console.log`:**

```typescript
play: async ({ canvas }) => {
  const textarea = canvas.getByRole('textbox');
  console.log('Textarea found:', textarea);
  await userEvent.type(textarea, 'Test');
};
```

2. **Используй `canvas.debug()`:**

```typescript
play: async ({ canvas }) => {
  canvas.debug(); // Выводит весь DOM в console
};
```

3. **Увеличь timeouts:**

```typescript
const toast = await canvas.findByText(/success/i, {}, { timeout: 5000 });
```

4. **Проверь queries:**

```typescript
// Если getByRole не находит, проверь что есть:
canvas.getAllByRole('button').forEach((btn) => console.log(btn.textContent));
```

---

## 7. 🎭 Mocking в Storybook 9

### Что такое Mocking?

**Mocking** - подмена внешних зависимостей (API calls, server actions, hooks) для изолированного тестирования компонентов в Storybook.

**📚 ЗАЧЕМ НУЖЕН:**

1. **Изоляция** - компонент работает без реального бэкенда
2. **Предсказуемость** - контролируем все ответы
3. **Скорость** - нет реальных HTTP запросов
4. **Все сценарии** - легко тестировать ошибки и edge cases

---

### Новый API в Storybook 9

**⚠️ ВАЖНО:** В Storybook 9 изменился способ мокирования!

#### ❌ Старый способ (Storybook 8)

```typescript
// НЕ РАБОТАЕТ в Storybook 9
import { fn } from '@storybook/test';

const meta = {
  args: {
    onSubmit: fn(), // ❌ Устарело
  },
};
```

#### ✅ Новый способ (Storybook 9)

**Шаг 1:** Зарегистрировать мок в `.storybook/preview.ts`

```typescript
import { sb } from 'storybook/test';

// ВАЖНО: Регистрация мока ОБЯЗАТЕЛЬНА в preview файле
sb.mock(import('next/navigation')); // Полный мок модуля
```

**Шаг 2:** Использовать мок в stories

```typescript
import { mocked, fn } from 'storybook/test';
import { useRouter } from 'next/navigation';

export const WithRouter: Story = {
  beforeEach: async () => {
    // Настроить поведение мока
    mocked(useRouter).mockReturnValue({
      push: fn(),
      pathname: '/todos',
    });
  },
  play: async ({ canvas }) => {
    // Проверить что мок был вызван
    await expect(useRouter).toHaveBeenCalled();
  },
};
```

---

### Примеры Mocking

#### Пример 1: Мокирование Server Actions

Если TaskInput использует server action `createTodoAction`:

**.storybook/preview.ts:**
```typescript
import { sb } from 'storybook/test';

// Регистрируем мок для server actions
sb.mock(import('@/core/todo/actions/create-todo.action'));
```

**TaskInput.stories.tsx:**
```typescript
import { mocked, fn } from 'storybook/test';
import { createTodoAction } from '@/core/todo/actions/create-todo.action';

export const SuccessfulSubmit: Story = {
  beforeEach: async () => {
    // Мок успешного создания
    mocked(createTodoAction).mockResolvedValue({
      success: true,
      data: { id: '1', description: 'Test task' },
    });
  },
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('User submits task', async () => {
      await userEvent.type(canvas.getByRole('textbox'), 'Test task');
      await userEvent.click(canvas.getByRole('button', { name: /create/i }));
    });

    await step('Verify action was called', async () => {
      await expect(createTodoAction).toHaveBeenCalledWith('Test task');
    });
  },
};

export const FailedSubmit: Story = {
  beforeEach: async () => {
    // Мок ошибки
    mocked(createTodoAction).mockResolvedValue({
      success: false,
      error: 'Network error',
    });
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);
    await userEvent.type(canvas.getByRole('textbox'), 'Test');
    await userEvent.click(canvas.getByRole('button'));

    // Проверить что показалась ошибка
    await expect(await canvas.findByText(/network error/i)).toBeInTheDocument();
  },
};
```

---

#### Пример 2: Мокирование toast notifications

**.storybook/preview.ts:**
```typescript
import { sb } from 'storybook/test';

sb.mock(import('sonner')); // Мок для toast
```

**Story с проверкой toast:**
```typescript
import { mocked } from 'storybook/test';
import { toast } from 'sonner';

export const ShowsSuccessToast: Story = {
  beforeEach: async () => {
    mocked(toast.success).mockImplementation(() => '1');
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Submit form
    await userEvent.type(canvas.getByRole('textbox'), 'New task');
    await userEvent.click(canvas.getByRole('button'));

    // Verify toast was shown
    await expect(toast.success).toHaveBeenCalledWith('Task created');
  },
};
```

---

### API Reference

#### `sb.mock()`

Регистрирует модуль для мокирования (ТОЛЬКО в preview файле).

```typescript
// .storybook/preview.ts
import { sb } from 'storybook/test';

sb.mock(import('module-name')); // Полный мок
```

#### `mocked()`

Получает типизированный мок функции.

```typescript
import { mocked } from 'storybook/test';
import { myFunction } from 'module';

mocked(myFunction).mockReturnValue('result');
mocked(myFunction).mockResolvedValue(Promise.resolve('async result'));
```

#### `fn()`

Создает spy function для отслеживания вызовов.

```typescript
import { fn } from 'storybook/test';

const onClick = fn();

// В assertions
await expect(onClick).toHaveBeenCalled();
await expect(onClick).toHaveBeenCalledWith('arg');
await expect(onClick).toHaveBeenCalledTimes(2);
```

---

### Best Practices для Mocking

1. **Всегда регистрируй моки в preview.ts**
   - ❌ Не мокируй напрямую в stories
   - ✅ Используй `sb.mock()` в preview файле

2. **Используй `beforeEach` для setup**
   - Сброс моков между stories автоматический
   - Настраивай поведение в `beforeEach`

3. **Мокируй внешние зависимости**
   - Server actions
   - API calls
   - Navigation (next/navigation)
   - Toast notifications
   - Third-party libraries

4. **Проверяй моки в play functions**
   - Используй `expect()` для assertions
   - Проверяй что моки вызываются правильно

5. **Документируй моки**
   - Комментируй что мокируется и почему
   - Объясняй возвращаемые значения

---

## 8. 🎨 Args Композиция

### Проблема: Дублирование args

**❌ ПЛОХО - дублирование во всех stories:**

```typescript
export const Story1: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
    required: true,
    disabled: false,
    minRows: 1,
    maxRows: 5,
  },
};

export const Story2: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
    required: true,
    disabled: true, // ← только это отличается
    minRows: 1,
    maxRows: 5,
  },
};
```

---

### Решение: Default args в meta

**✅ ХОРОШО - композиция через meta:**

```typescript
const meta = {
  args: {
    // Default для ВСЕХ stories
    label: 'Task',
    placeholder: 'Enter task...',
    required: true,
    disabled: false,
    minRows: 1,
    maxRows: 5,
  },
} satisfies Meta<typeof TaskInput>;

export const Story1: Story = {
  // Наследует все из meta
};

export const Story2: Story = {
  args: {
    disabled: true, // Override только нужное
  },
};
```

**📚 ПРИОРИТЕТЫ:**

```
story.args > meta.args
```

Story args **переопределяют** meta args.

---

### Композиция через spread

Если нужно переиспользовать args между stories:

```typescript
const baseTaskArgs = {
  label: 'Task Description',
  placeholder: 'What needs to be done?',
};

export const Short: Story = {
  args: {
    ...baseTaskArgs,
    minRows: 1,
    maxRows: 3,
  },
};

export const Long: Story = {
  args: {
    ...baseTaskArgs,
    minRows: 3,
    maxRows: 10,
  },
};
```

**💡 КОГДА ИСПОЛЬЗОВАТЬ:**

- Для группы связанных stories
- Когда нужно несколько вариаций с общей базой

---

## 9. 🎚️ ArgTypes Best Practices

### Категории для группировки

```typescript
argTypes: {
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 📝 CONTENT - контент компонента
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  label: {
    control: 'text',
    description: 'Label text displayed above the input',
    table: {
      category: 'Content',
      type: { summary: 'string' },
      defaultValue: { summary: 'Task Description' },
    },
  },
  placeholder: {
    control: 'text',
    description: 'Placeholder text when input is empty',
    table: {
      category: 'Content',
      type: { summary: 'string' },
    },
  },

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // ✅ VALIDATION - валидация
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  required: {
    control: 'boolean',
    description: 'Whether the field is required',
    table: {
      category: 'Validation',
      type: { summary: 'boolean' },
      defaultValue: { summary: 'true' },
    },
  },
  issues: {
    control: 'object',
    description: 'Zod validation errors to display',
    table: {
      category: 'Validation',
      type: { summary: 'ZodIssue[]' },
    },
  },

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 🎛️ STATE - состояние компонента
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  disabled: {
    control: 'boolean',
    description: 'Whether the input is disabled',
    table: {
      category: 'State',
      type: { summary: 'boolean' },
      defaultValue: { summary: 'false' },
    },
  },

  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  // 📐 LAYOUT - размеры и расположение
  // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  minRows: {
    control: { type: 'number', min: 1, max: 10 },
    description: 'Minimum number of visible rows',
    table: {
      category: 'Layout',
      type: { summary: 'number' },
      defaultValue: { summary: '1' },
    },
  },
  maxRows: {
    control: { type: 'number', min: 1, max: 20 },
    description: 'Maximum rows before scrolling',
    table: {
      category: 'Layout',
      type: { summary: 'number' },
      defaultValue: { summary: '5' },
    },
  },
}
```

**📚 РЕКОМЕНДУЕМЫЕ КАТЕГОРИИ:**

| Категория    | Для чего                      |
| ------------ | ----------------------------- |
| `Content`    | Text, labels, descriptions    |
| `Validation` | Required, errors, constraints |
| `State`      | Disabled, loading, readonly   |
| `Layout`     | Sizes, spacing, positioning   |
| `Styling`    | Colors, variants, themes      |
| `Behavior`   | Callbacks, handlers, actions  |

---

### Таблица Control Types

| Control   | Input Type    | Пример Props                              |
| --------- | ------------- | ----------------------------------------- |
| `text`    | Text input    | label, placeholder, description           |
| `boolean` | Checkbox      | disabled, required, loading               |
| `number`  | Number input  | minRows, maxRows, timeout                 |
| `range`   | Slider        | opacity (0-1), fontSize (12-24)           |
| `select`  | Dropdown      | variant, size, position                   |
| `radio`   | Radio buttons | alignment ('left' \| 'center' \| 'right') |
| `color`   | Color picker  | backgroundColor, textColor                |
| `date`    | Date picker   | createdAt, updatedAt                      |
| `object`  | JSON editor   | style, config                             |
| `array`   | Array editor  | items, tags                               |

---

## 10. 🎭 Decorators

### Три уровня decorators

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 1️⃣ GLOBAL DECORATORS (.storybook/preview.ts)
// Применяются ко ВСЕМ stories во всех файлах
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const decorators = [
  withThemeByDataAttribute({...}),
  (Story) => (
    <>
      <Story />
      <Toaster /> {/* Для всех компонентов */}
    </>
  ),
];

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 2️⃣ COMPONENT DECORATORS (в meta)
// Применяются ко всем stories этого компонента
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const meta = {
  decorators: [
    (Story) => (
      <div style={{ padding: '2rem', maxWidth: '600px' }}>
        <Story />
      </div>
    ),
  ],
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 3️⃣ STORY DECORATORS (в конкретной story)
// Применяются только к этой story
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const SpecialCase: Story = {
  decorators: [
    (Story) => (
      <div className="bg-red-50 p-8">
        <Story />
      </div>
    ),
  ],
};
```

**📚 ПОРЯДОК ВЫПОЛНЕНИЯ:**

```
Story-level → Component-level → Global
```

Decorators применяются **справа налево** (от ближнего к дальнему).

---

### Примеры decorators

#### Padding Wrapper

```typescript
decorators: [
  (Story) => (
    <div style={{ padding: '2rem' }}>
      <Story />
    </div>
  ),
]
```

**Use case:** Отступы для всех stories

---

#### Max Width

```typescript
decorators: [
  (Story) => (
    <div style={{ maxWidth: '600px', margin: '0 auto' }}>
      <Story />
    </div>
  ),
]
```

**Use case:** Ограничить ширину form components

---

#### Provider Wrapper

```typescript
decorators: [
  (Story) => (
    <QueryClientProvider client={queryClient}>
      <Story />
    </QueryClientProvider>
  ),
]
```

**Use case:** React Query, Redux, Context

---

## 11. ✅ Best Practices Checklist

### Структура файла

- [ ] Default export с `meta` объектом
- [ ] Type `Story = StoryObj<typeof meta>`
- [ ] Named exports для stories (PascalCase)
- [ ] Imports в правильном порядке (types → component → utils)

### Meta Configuration

- [ ] `title`: правильная иерархия (Category/Component)
- [ ] `component`: ссылка на компонент
- [ ] `parameters.layout`: `'centered'` для forms/buttons
- [ ] `tags: ['autodocs']` для public components
- [ ] `args`: default значения в meta, не в stories
- [ ] `argTypes`: с категориями и descriptions
- [ ] `decorators`: padding wrapper (если нужен)

### Stories

- [ ] **Playground** - первая story (пустой объект)
- [ ] **Default** - минимальный working example
- [ ] **States** - error, disabled, loading, etc
- [ ] **Variants** - разные конфигурации
- [ ] **Interactive** - с play function для critical flows

### Args

- [ ] Default args в `meta.args`
- [ ] Story-specific args в `story.args`
- [ ] Нет дублирования через `...Default.args`
- [ ] Используй `undefined` для override (не удаляй props)

### ArgTypes

- [ ] Категории (`Content`, `Validation`, `State`, `Layout`)
- [ ] Descriptions для всех props
- [ ] Table metadata (type, defaultValue)
- [ ] Правильные control types

### Play Functions

- [ ] Используй `canvas = within(canvasElement)`
- [ ] Организуй через `step()`
- [ ] `userEvent` (не `fireEvent`)
- [ ] `getByRole` > `getByText` > `getByTestId`
- [ ] Assertions с `expect()` (если нужно)

### Naming

- [ ] Stories: PascalCase (`Playground`, `WithError`)
- [ ] Args: camelCase (`minRows`, `submitLabel`)
- [ ] Файл: `ComponentName.stories.tsx`

---

## 12. 📦 Полный TaskInput.stories.tsx

Вот полный файл с применением ВСЕХ best practices:

```typescript
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📦 IMPORTS
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
import type { Meta, StoryObj } from '@storybook/nextjs-vite';
import { expect, userEvent, within } from 'storybook/test';
import { TaskInput } from './index';

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎛️ META CONFIGURATION
//
// Определяет настройки для ВСЕХ stories компонента TaskInput
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
const meta = {
  // 📍 Путь в Storybook sidebar
  title: 'Design System/TaskInput',

  // 🎯 Компонент для stories
  component: TaskInput,

  // ⚙️ Настройки отображения
  parameters: {
    layout: 'centered', // Центрирование в canvas
  },

  // 🏷️ Автодокументация
  tags: ['autodocs'],

  // 🎛️ Default args для ВСЕХ stories
  // Каждая story наследует эти значения
  // Story может переопределить через свои args
  args: {
    label: 'Task Description',
    placeholder: 'Enter your task...',
    required: true,
    disabled: false,
    submitLabel: 'Create task',
    minRows: 1,
    maxRows: 5,
  },

  // 🎚️ ArgTypes - controls и документация
  argTypes: {
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 📝 CONTENT
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    label: {
      control: 'text',
      description: 'Label text displayed above the input',
      table: {
        category: 'Content',
        type: { summary: 'string' },
        defaultValue: { summary: 'Task Description' },
      },
    },
    placeholder: {
      control: 'text',
      description: 'Placeholder text shown when input is empty',
      table: {
        category: 'Content',
        type: { summary: 'string' },
      },
    },
    description: {
      control: 'text',
      description: 'Helper text displayed below the input',
      table: {
        category: 'Content',
        type: { summary: 'string' },
      },
    },
    defaultValue: {
      control: 'text',
      description: 'Initial value of the textarea',
      table: {
        category: 'Content',
        type: { summary: 'string' },
      },
    },
    submitLabel: {
      control: 'text',
      description: 'Submit button label text',
      table: {
        category: 'Content',
        type: { summary: 'string' },
        defaultValue: { summary: 'Create task' },
      },
    },

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ✅ VALIDATION
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    required: {
      control: 'boolean',
      description: 'Whether the input is required',
      table: {
        category: 'Validation',
        type: { summary: 'boolean' },
        defaultValue: { summary: 'true' },
      },
    },
    issues: {
      control: 'object',
      description: 'Zod validation errors to display',
      table: {
        category: 'Validation',
        type: { summary: 'ZodIssue[]' },
      },
    },

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 🎛️ STATE
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    disabled: {
      control: 'boolean',
      description: 'Whether the input is disabled',
      table: {
        category: 'State',
        type: { summary: 'boolean' },
        defaultValue: { summary: 'false' },
      },
    },

    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 📐 LAYOUT
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    minRows: {
      control: { type: 'number', min: 1, max: 10 },
      description: 'Minimum number of rows for textarea',
      table: {
        category: 'Layout',
        type: { summary: 'number' },
        defaultValue: { summary: '1' },
      },
    },
    maxRows: {
      control: { type: 'number', min: 1, max: 20 },
      description: 'Maximum number of rows before scrolling',
      table: {
        category: 'Layout',
        type: { summary: 'number' },
        defaultValue: { summary: '5' },
      },
    },
  },

  // 🎨 Decorators - wrapper для визуализации
  decorators: [
    (Story) => (
      <div style={{ padding: '2rem', maxWidth: '600px' }}>
        <Story />
      </div>
    ),
  ],
} satisfies Meta<typeof TaskInput>;

export default meta;
type Story = StoryObj<typeof meta>;

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎮 PLAYGROUND
// Интерактивная песочница с полным контролем
//
// Все args из meta доступны через Controls panel
// Можно менять любой prop в реальном времени
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Playground: Story = {
  // Пустой объект - наследует все из meta
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📄 DEFAULT
// Минимальный рабочий пример
//
// Quick start для разработчиков:
// "Скопируй этот код и все заработает"
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Default: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🔍 WITHOUT LABEL
// Компонент БЕЗ label - только placeholder
//
// Use cases:
// - Inline editing
// - Search bars
// - Minimalist forms
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const WithoutLabel: Story = {
  args: {
    label: undefined, // Override meta value
    placeholder: 'Type here...',
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ❌ WITH ERROR
// Состояние ошибки валидации (Zod issues)
//
// Показывает:
// - Error message styling
// - Accessibility (aria-invalid, aria-describedby)
// - Multiple errors handling
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const WithError: Story = {
  args: {
    issues: [
      {
        code: 'too_small',
        minimum: 3,
        type: 'string',
        inclusive: true,
        exact: false,
        message: 'Task must be at least 3 characters',
        path: ['description'],
      },
    ],
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🚫 DISABLED
// Disabled state - нельзя редактировать
//
// UX scenarios:
// - Form loading
// - Insufficient permissions
// - Conditional logic (enable after other fields)
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Disabled: Story = {
  args: {
    disabled: true,
    defaultValue: 'This field is disabled',
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ✍️ FILLED
// Форма с предзаполненным значением
//
// Use cases:
// - Edit mode (existing todo)
// - Draft recovery
// - URL params pre-fill
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Filled: Story = {
  args: {
    defaultValue: 'Buy groceries for dinner tonight',
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 📝 LONG TEXT
// Поведение с длинным текстом (auto-resize)
//
// Демонстрирует:
// - minRows/maxRows механизм
// - Scroll появление после maxRows
// - UX с multiline контентом
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const LongText: Story = {
  args: {
    label: 'Project Description',
    minRows: 3,
    maxRows: 6,
    defaultValue: `This is a long task description that spans multiple lines.
It demonstrates the auto-resize behavior of the textarea component.
The component will grow from minRows (3) to maxRows (6).
After maxRows, a scrollbar will appear.
This helps maintain good UX with long content.
Users can type as much as they want.`,
  },
};

// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// 🎬 INTERACTIVE
// Автоматическая демонстрация через Play Function
//
// Симулирует:
// 1. User types task description
// 2. User submits the form
//
// Полезно для:
// - Демонстрация user flow
// - Smoke testing
// - Visual regression testing
// - Показ stakeholders
// ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
export const Interactive: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('User types task description', async () => {
      const textarea = canvas.getByRole('textbox');
      await userEvent.type(textarea, 'Buy groceries for dinner', {
        delay: 50, // Медленно для визуализации
      });
    });

    await step('User submits the form', async () => {
      const submitBtn = canvas.getByRole('button', { name: /create task/i });
      await userEvent.click(submitBtn);
    });
  },
};
```

---

## 13. 📚 STORYBOOK.md Update

Добавь эту секцию в конец `STORYBOOK.md`:

````markdown
## Writing Stories - Best Practices

### Required Setup

**⚠️ ВАЖНО:** Before writing stories, убедись что Toaster настроен:

1. **В `src/app/layout.tsx`** - добавь `<Toaster />` внутри `<ThemeProvider>`
2. **В `.storybook/preview.ts`** - добавь Toaster как global decorator

См. [`docs/STORYBOOK_TASKINPUT_LESSON.md`](./docs/STORYBOOK_TASKINPUT_LESSON.md#1-критический-баг-toaster-не-работает) для деталей.

---

### Story Patterns

Каждый stories файл должен включать:

#### 1. Playground Story

Интерактивная песочница с полным контролем через Controls panel.

```typescript
export const Playground: Story = {};
// Пустой объект - наследует все args из meta
```
````

**Зачем:** Main example, первая story, показывает все возможности.

---

#### 2. Default Story

Минимальный рабочий пример.

```typescript
export const Default: Story = {
  args: {
    label: 'Task',
    placeholder: 'Enter task...',
  },
};
```

**Зачем:** Quick start для разработчиков.

---

#### 3. State Stories

Различные состояния компонента.

```typescript
export const WithError: Story = { args: { issues: [...] } };
export const Disabled: Story = { args: { disabled: true } };
export const Filled: Story = { args: { defaultValue: '...' } };
```

**Зачем:** Покрыть все use cases.

---

#### 4. Interactive Story (Play Function)

Автоматическая демонстрация user flow.

```typescript
export const Interactive: Story = {
  play: async ({ canvasElement, step }) => {
    const canvas = within(canvasElement);

    await step('User action', async () => {
      await userEvent.type(canvas.getByRole('textbox'), 'Text');
    });
  },
};
```

**Зачем:** Живая демонстрация, automated testing.

---

### Best Practices Checklist

- [ ] Default args в `meta.args` (не в stories)
- [ ] ArgTypes с категориями (`Content`, `Validation`, `State`, `Layout`)
- [ ] Decorators для padding/layout если нужно
- [ ] `parameters.layout: 'centered'` для form components
- [ ] `tags: ['autodocs']` для public components
- [ ] Playground как первая story
- [ ] Play functions для critical flows

---

### Reference Implementation

См. **[`TaskInput.stories.tsx`](../src/components/TaskInput/TaskInput.stories.tsx)** как пример всех best practices.

### Полный Tutorial

См. **[`docs/STORYBOOK_TASKINPUT_LESSON.md`](./docs/STORYBOOK_TASKINPUT_LESSON.md)** для подробного учебника с объяснениями.

```

---

## 🎉 Заключение

Теперь у тебя есть:

✅ **Полное понимание** Storybook 9 best practices
✅ **Reference implementation** в TaskInput.stories.tsx
✅ **Решение бага** с Toaster
✅ **Play Functions** для автоматических interactions
✅ **Playground pattern** для интерактивного тестирования
✅ **Checklist** для будущих компонентов

### Следующие шаги

1. **Исправь баг:**
   - Добавь `<Toaster />` в `layout.tsx`
   - Добавь Toaster decorator в `preview.ts`
   - Перезапусти Storybook

2. **Переиспользуй паттерны:**
   - Скопируй структуру TaskInput.stories.tsx
   - Примени к другим компонентам
   - Следуй checklist из раздела 10

3. **Изучай дальше:**
   - Storybook Interactions addon
   - Visual regression testing с Chromatic
   - Component testing с @storybook/addon-vitest

---

**Автор:** Claude Code
**Дата:** 2025-10-23
**Версия:** 1.0
```
